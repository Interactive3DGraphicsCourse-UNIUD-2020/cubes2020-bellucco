<html>
	<head>
		<title>Starting Code for 1st Project 2017</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
	</head>
	<body>
		
		<script>
		
		var scene, camera, renderer, controls, stats;
		var loader = new THREE.ObjectLoader();

		var loadedHeightMap = false;
		var data;
		var gridX, gridZ;
		var terrain = new Array();

		var loadedtree = false;
		var tree;
		var planted = 0;
		var toplant = new Array(14);
		
		var latocubo = 1;

		var imgl = new THREE.TextureLoader();
		var grass = new THREE.MeshPhongMaterial({map: imgl.load("textures/grass.jpg")});
		var side = new THREE.MeshPhongMaterial({map: imgl.load("textures/side.jpg")});
		//var dirt = new THREE.MeshPhongMaterial({map: imgl.load("textures/dirt.jpg")});
		var earthcube = [side, side, grass, side, side, side];

		//var m = new THREE.MeshPhongMaterial({ map: img });
		var g = new THREE.BoxGeometry(latocubo, latocubo, latocubo);
		//var cube = new THREE.Mesh(g, earthcube);

		//return array with height data from img, taken from: http://danni-three.blogspot.it/2013/09/threejs-heightmaps.html
		function getHeightData(img,scale) {
  
		 if (scale == undefined) scale=1;
  
		    var canvas = document.createElement( 'canvas' );
		    canvas.width = img.width;
		    canvas.height = img.height;
		    var context = canvas.getContext( '2d' );
 
		    var size = img.width * img.height;
			gridX = img.width;
			gridZ = img.height;
			console.log(size);
		    var data = new Float32Array( size );
 
		    context.drawImage(img,0,0);
 
		    for ( var i = 0; i < size; i ++ ) {
		        data[i] = 0
		    }
 
		    var imgd = context.getImageData(0, 0, img.width, img.height);
		    var pix = imgd.data;
 
		    var j=0;
		    for (var i = 0; i<pix.length; i +=4) {
		        var all = pix[i]+pix[i+1]+pix[i+2];
		        data[j++] = all*scale/3;
		    }
     
		    return data;
		}
		
		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			document.body.appendChild( renderer.domElement );
			
			camera.position.set(20,60,80);
			camera.lookAt( new THREE.Vector3(0,0,0));
			/*
			hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
			hemiLight.color.setHSL( 0.6, 1, 0.6 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 500, 0 );
			scene.add( hemiLight );
			*/
			dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( -1, 1.75, 1 );
			dirLight.position.multiplyScalar( 50 );
			scene.add( dirLight );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			
			// uncomment if you need to draw coordinate axes when building the scene
			Coordinates.drawAllAxes();
			
			controls = new THREE.OrbitControls( camera );
		}

		function TreeLoader() {
			tree = new THREE.Object3D();
			var albero = loader.load("models/scene.json", 
				function(obj) {
					tree = obj;
					loadedtree = true;
				}
			);
			console.log(tree);
		}
		
		function Loader() {
			data = new Array();
			var imgLoader = new THREE.ImageLoader();

			var img = imgLoader.load("textures/hm7.png",
				//onload callback
				function (image) {
					data = getHeightData(image, 0.1);
					console.log("data:", data);
					loadedHeightMap = true;
				},
				//progress callback
				undefined,
				//onerror callback
				function () { console.error('An error happened.'); }
			);

		}

		function Update() {
			requestAnimationFrame( Update );
			controls.update();  
			stats.update();
			Render();
		}
		
		function Render() {
			
			if(loadedHeightMap) {
				//camera.lookAt(new THREE.Vector3(gridX/2, 0, gridZ/2));
				
				console.log(terrain.length);
				if(terrain.length == 0) {
					console.log(gridX, gridZ);
					var num = 0;
					/*for(i=0; i<gridX; i++) {
						terrain[i] = new Array();
						for(j=0; j<gridZ; j++) {
							if(i==gridX-1 
								|| j==gridZ-1 
								|| i==0 
								|| j==0) 
								g = new THREE.BoxGeometry(latocubo, Math.floor(data[num]), latocubo);
							else if(data[num+1]<data[num] 
								|| data[num-1]<data[num]
								|| data[num+gridX]<data[num] 
								|| data[num-gridX]<data[num])
								g = new THREE.BoxGeometry(latocubo, Math.floor(data[num]), latocubo);
							else g = new THREE.BoxGeometry(latocubo, latocubo, latocubo);
							
							cube = new THREE.Mesh(g, m);
							cube.position.x = i;
							cube.position.z = j;

							var alt = Math.floor(data[num]);
							if(i==gridX-1 
								|| j==gridZ-1 
								|| i==0 
								|| j==0) 
								cube.position.y = alt==0? latocubo/2 : alt/2;
							else if(Math.floor(data[num+1])<Math.floor(data[num]) 
								|| Math.floor(data[num-1])<Math.floor(data[num])
								|| Math.floor(data[num+gridX])<Math.floor(data[num])
								|| Math.floor(data[num-gridX])<Math.floor(data[num])) 
								cube.position.y = alt==0? latocubo/2 : alt/2;
							else cube.position.y = alt==0? latocubo/2 : alt-latocubo/2;
							terrain[i][j] = cube;
							num++;
							scene.add(cube);
						}
					}*/
					for(i=0; i<gridX; i++) {
						terrain[i] = new Array();
						for(j=0; j<gridZ; j++) {
							terrain[i][j] = new Array();

							var alt = Math.floor(data[num]);

							cube = new THREE.Mesh(g, earthcube);
							cube.position.x = i;
							cube.position.z = j;
							cube.position.y = alt==0? latocubo/2 : alt-latocubo/2;
							terrain[i][j][0] = cube;
							scene.add(cube);

							
							if(i==gridX-1 || j==gridZ-1 || i==0 || j==0) {
								for(w=0; w<(alt-latocubo/latocubo); w++) {
									cube2 = new THREE.Mesh(g, earthcube);
									cube2.position.x = i;
									cube2.position.z = j;
									cube2.position.y = latocubo/2 + w;
									terrain[i][j][w+1] = cube2;
									scene.add(cube2);
								}
							}
							else if(Math.floor(data[num+1])<Math.floor(data[num]) 
								|| Math.floor(data[num-1])<Math.floor(data[num])
								|| Math.floor(data[num+gridX])<Math.floor(data[num])
								|| Math.floor(data[num-gridX])<Math.floor(data[num])) 
								{
									var maxdiff = Math.min(Math.floor(data[num+1]), Math.floor(data[num-1]), Math.floor(data[num+gridX]), Math.floor(data[num-gridX]));
									for(w=(maxdiff); w<(alt-latocubo/latocubo); w++) {
										cube2 = new THREE.Mesh(g, earthcube);
										cube2.position.x = i;
										cube2.position.z = j;
										cube2.position.y = latocubo/2 + w;
										terrain[i][j][w+1] = cube2;
										scene.add(cube2);
								}
							}
							num++;
						}
					}
				}
				/* else {
					for(i=0; i<terrain.length; i++)
						for(j=0; j<terrain[i].length; j++) {}
							//scene.add(terrain[i][j]);
				}*/
			};
			renderer.render(scene, camera);
		}
		
		Loader();
		Start();
		Update();
			
		</script>
	</body>
</html>