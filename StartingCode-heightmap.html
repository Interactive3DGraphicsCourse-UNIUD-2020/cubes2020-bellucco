<html>
	<head>
		<title>Starting Code for 1st Project 2017</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
	</head>
	<body>
		
		<script>
		
		var scene, camera, renderer, controls, stats;
		var loadedHeightMap = false;
		var data;
		var gridX, gridZ;
		var terrain = new Array();
		var latocubo = 1;
		var m = new THREE.MeshPhongMaterial({ color: 0x0000ff });
		var g;
		var cube;

		//return array with height data from img, taken from: http://danni-three.blogspot.it/2013/09/threejs-heightmaps.html
		function getHeightData(img,scale) {
  
		 if (scale == undefined) scale=1;
  
		    var canvas = document.createElement( 'canvas' );
		    canvas.width = img.width;
		    canvas.height = img.height;
		    var context = canvas.getContext( '2d' );
 
		    var size = img.width * img.height;
			gridX = img.width;
			gridZ = img.height;
			console.log(size);
		    var data = new Float32Array( size );
 
		    context.drawImage(img,0,0);
 
		    for ( var i = 0; i < size; i ++ ) {
		        data[i] = 0
		    }
 
		    var imgd = context.getImageData(0, 0, img.width, img.height);
		    var pix = imgd.data;
 
		    var j=0;
		    for (var i = 0; i<pix.length; i +=4) {
		        var all = pix[i]+pix[i+1]+pix[i+2];
		        data[j++] = all*scale/3;
		    }
     
		    return data;
		}
		
		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			document.body.appendChild( renderer.domElement );
			
			camera.position.set(20,60,80);
			camera.lookAt( new THREE.Vector3(0,0,0));
			/*
			hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
			hemiLight.color.setHSL( 0.6, 1, 0.6 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 500, 0 );
			scene.add( hemiLight );
			*/
			dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( -1, 1.75, 1 );
			dirLight.position.multiplyScalar( 50 );
			scene.add( dirLight );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			
			// uncomment if you need to draw coordinate axes when building the scene
			Coordinates.drawAllAxes();
			
			controls = new THREE.OrbitControls( camera );
			
		}
		
		function Loader() {

			var imgLoader = new THREE.ImageLoader();

			var img = imgLoader.load("textures/hm7.png",
				//onload callback
				function (image) {
					data = getHeightData(image, 0.1);
					console.log("data:", data);
					loadedHeightMap = true;
				},
				//progress callback
				undefined,
				//onerror callback
				function () { console.error('An error happened.'); }
			);
		}

		function Update() {
			requestAnimationFrame( Update );
			controls.update();  
			stats.update();
			Render();
		}
		
		function Render() {
			
			if(loadedHeightMap) {
				//camera.lookAt(new THREE.Vector3(gridX/2, 0, gridZ/2));
				
				console.log(terrain.length);
				if(terrain.length == 0) {
					console.log(gridX, gridZ);
					var num = 0;
					for(i=0; i<gridX; i++) {
						terrain[i] = new Array();
						for(j=0; j<gridZ; j++) {
							if(i==gridX-1 || j==gridZ-1 || i==0 || j==0) g = new THREE.BoxGeometry(latocubo, data[num], latocubo);
							else if(data[num+1]<data[num] || data[num-1]<data[num]
									|| data[num+gridX]<data[num] || data[num-gridX]<data[num]) 
								g = new THREE.BoxGeometry(latocubo, data[num], latocubo);
							else g = new THREE.BoxGeometry(latocubo, latocubo, latocubo);
							
							cube = new THREE.Mesh(g, m);
							cube.position.x = i;
							cube.position.z = j;
							if(i==gridX-1 || j==gridZ-1 || i==0 || j==0) cube.position.y = data[num]/2;
							else if(data[num+1]<data[num] || data[num-1]<data[num]
									|| data[num+gridX]<data[num] || data[num-gridX]<data[num]) 
								cube.position.y = data[num]/2;
							else cube.position.y = data[num]-latocubo/2;
							terrain[i][j] = cube;
							num++;
							scene.add(cube);
						}
					}
				}
				/* else {
					for(i=0; i<terrain.length; i++)
						for(j=0; j<terrain[i].length; j++) {}
							//scene.add(terrain[i][j]);
				}*/
			};
			renderer.render(scene, camera);
		}
		
		Loader();
		Start();
		Update();
			
		</script>
	</body>
</html>