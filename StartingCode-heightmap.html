<html>
	<head>
		<title>Starting Code for 1st Project 2017</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
	</head>
	<body>
		
		<script>
		var rotation = 0;
		var direction = true;

		var scene, camera, renderer, controls, stats;
		var loader = new THREE.ObjectLoader();

		var loadedHeightMap = false;
		var data;
		var gridX, gridZ;
		var terrain = new Array();

		var loadedtree = false;
		var tree;
		var planted = 0;
		var toplant = new Array(30);

		var lsphere, lmaterial;
		var lava1, lava2, lava3;

		var latocubo = 1;

		var imgl = new THREE.TextureLoader();
		var grass = new THREE.MeshLambertMaterial({map: imgl.load("textures/grass.jpg")});
		var side = new THREE.MeshLambertMaterial({map: imgl.load("textures/side.jpg")});
		var dirt = new THREE.MeshLambertMaterial({map: imgl.load("textures/dirt.jpg")});
		var stone = new THREE.MeshLambertMaterial({map: imgl.load("textures/stone.jpg")})
		var obsidian = new THREE.MeshLambertMaterial({map: imgl.load("textures/obsidian.jpg")})
		var water = new THREE.MeshLambertMaterial({map: imgl.load("textures/water.png")})
		var earthcube = [side, side, grass, side, side, side];

		var wood = new THREE.MeshLambertMaterial({map: imgl.load("textures/wood.jpg")});
		var leaves = new THREE.MeshLambertMaterial({map: imgl.load("textures/leaves.png")})
		
		var g = new THREE.BoxGeometry(latocubo, latocubo, latocubo);
		
		function getHeightData(img,scale) {
  
		 if (scale == undefined) scale=1;
  
		    var canvas = document.createElement( 'canvas' );
		    canvas.width = img.width;
		    canvas.height = img.height;
		    var context = canvas.getContext( '2d' );
 
		    var size = img.width * img.height;
			gridX = img.width;
			gridZ = img.height;
			//console.log(size);
		    var data = new Float32Array( size );
 
		    context.drawImage(img,0,0);
 
		    for ( var i = 0; i < size; i ++ ) {
		        data[i] = 0
		    }
 
		    var imgd = context.getImageData(0, 0, img.width, img.height);
		    var pix = imgd.data;
 
		    var j=0;
		    for (var i = 0; i<pix.length; i +=4) {
		        var all = pix[i]+pix[i+1]+pix[i+2];
		        data[j++] = all*scale/3;
		    }
     
		    return data;
		}
		
		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			//renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );
			
			camera.position.set(160, 60, 60);
			
			//scene.add(new THREE.AmbientLight(0x444444));

			dirLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( -1, 1.75, 1 );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;

			//scene.add( dirLight );

			lsphere = new THREE.SphereBufferGeometry(1, 32, 32);
            lmaterial = new THREE.MeshPhongMaterial({color: 0xff0000});

			lava1 = new THREE.PointLight(0xff0000, 1, 200);
			lava1.position.set(60,30,60);
            lava1.add(new THREE.Mesh(lsphere, lmaterial));
            //scene.add(lava1);

			lmaterial = new THREE.MeshPhongMaterial({color: 0xffff00});
			lava2 = new THREE.PointLight(0xffff00, 1, 200);
			lava2.position.set(60,40,60);
            lava2.add(new THREE.Mesh(lsphere, lmaterial));
            //scene.add(lava2);

			lmaterial = new THREE.MeshPhongMaterial({color: 0xfd6a02});
			lava3 = new THREE.PointLight(0xfd6a02, 1, 200);
			lava3.position.set(60,20,60);
            lava3.add(new THREE.Mesh(lsphere, lmaterial));
			lava3.castShadow = true;
            scene.add(lava3);

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			
			Coordinates.drawAllAxes();
			
			controls = new THREE.OrbitControls( camera );
		}

		function TreeLoader() {
			tree = new THREE.Object3D();
			var albero = loader.load("models/scene.json", 
				function(obj) {
					tree = obj;
					loadedtree = true;
				}
			);
			//console.log(tree);
		}
		
		function Loader() {
			data = new Array();
			var imgLoader = new THREE.ImageLoader();

			var img = imgLoader.load("textures/hm7.png",
				//onload callback
				function (image) {
					data = getHeightData(image, 0.1);
					//console.log("data:", data);
					loadedHeightMap = true;
				}
			);

		}

		function Update() {
			requestAnimationFrame( Update );
			controls.update();  
			stats.update();
			Render();
		}
		
		function Render() {
			//console.log(camera);
			if(loadedHeightMap) {

				if(terrain.length == 0) {

					var num = 0;
					var max = Math.max(...data);

					for(i=0; i<gridX; i++) {
						terrain[i] = new Array();
						for(j=0; j<gridZ; j++) {
							terrain[i][j] = new Array();

							var alt = Math.floor(data[num]);
							
							var texture = Math.floor(Math.sqrt( (gridZ/2-j-4)*(gridZ/2-j-4) + (gridX/2-i-4)*(gridX/2-i-4)))<12? obsidian
							// && j<gridZ-gridZ/2.2 && i<gridX-gridX/2.2 && j>gridZ/2.6? obsidian
										: alt>max/5 ? stone 
										: alt>max/10 ? dirt 
										: alt==0 ? water 
										: earthcube;

							cube = new THREE.Mesh(g, texture);
							cube.position.x = i;
							cube.position.z = j;
							cube.position.y = alt==0? latocubo/2 : alt-latocubo/2;
							terrain[i][j][0] = cube;
							cube.castShadow = true;
							cube.receiveShadow = true;
							scene.add(cube);

							
							if(i==gridX-1 || j==gridZ-1 || i==0 || j==0) {
								for(w=0; w<(alt-latocubo/latocubo); w++) {
									cube2 = new THREE.Mesh(g, texture);
									cube2.position.x = i;
									cube2.position.z = j;
									cube2.position.y = latocubo/2 + w;
									terrain[i][j][w+1] = cube2;
									cube2.castShadow = true;
									cube2.receiveShadow = true;
									scene.add(cube2);
								}
							}
							else if(Math.floor(data[num+1])<Math.floor(data[num]) 
								|| Math.floor(data[num-1])<Math.floor(data[num])
								|| Math.floor(data[num+gridX])<Math.floor(data[num])
								|| Math.floor(data[num-gridX])<Math.floor(data[num])) 
								{
									var maxdiff = Math.min(Math.floor(data[num+1]), Math.floor(data[num-1]), Math.floor(data[num+gridX]), Math.floor(data[num-gridX]));
									for(w=(maxdiff); w<(alt-latocubo/latocubo); w++) {
										cube2 = new THREE.Mesh(g, texture);
										cube2.position.x = i;
										cube2.position.z = j;
										cube2.position.y = latocubo/2 + w;
										terrain[i][j][w+1] = cube2;
										cube2.castShadow = true;
										cube2.receiveShadow = true;
										scene.add(cube2);
								}
							}
							num++;
						}
					}

					while(planted<toplant.length) {
						var xcoord = Math.floor(Math.random()*(gridX-0)+0);
						var zcoord = Math.floor(Math.random()*(gridZ-0)+0);
						if(terrain[xcoord][zcoord].length > 1 && terrain[xcoord][zcoord].length < 11) {
							toplant[planted] = [xcoord, terrain[xcoord][zcoord].length, zcoord];
							//console.log(toplant[planted]);
							planted++;
						}
					}

					//console.log(toplant);
					//console.log(loadedtree);
					if(loadedtree) {
						for(i=0; i<toplant.length; i++) {
							var alb = tree.clone();
							//console.log(alb);
							for(x=0; x<alb.children.length; x++) {
								x<=5? alb.children[x].material = wood : alb.children[x].material = leaves;
							}
							alb.position.x = toplant[i][0];
							alb.position.y = toplant[i][1];
							alb.position.z = toplant[i][2];
							scene.add(alb);
						}
					};

				}

			};

			rotation += 0.1;
			/*
			if (direction) {
				rotation += 0.03;
				camera.position.z -= rotation/2;
				camera.position.x -= rotation/2;
				if(rotation>3.5)
					direction = false;
			} else {
				rotation -= 0.03;
				camera.position.z += rotation/2;
				camera.position.x += rotation/2;
				if(rotation<0)
					direction = true;

			}
			*/
			/*
			lava1.position.x = Math.cos(rotation*0.3)*20;
            lava1.position.y = Math.sin(rotation*0.5)*10;
            lava1.position.z = Math.cos(rotation*0.7)*15;

            lava2.position.x = Math.cos(rotation*0.7)*15;
            lava2.position.y = Math.sin(rotation*0.3)*20;
            lava2.position.z = Math.cos(rotation*0.5)*10;

            lava3.position.x = Math.cos(rotation*0.5)*15;
            lava3.position.y = Math.sin(rotation*0.7)*10;
            lava3.position.z = Math.cos(rotation*0.3)*20;
*/
			camera.lookAt(new THREE.Vector3(gridX/2, 0, gridZ/2));
			renderer.render(scene, camera);
		}
		
		Loader();
		TreeLoader();
		Start();
		Update();
			
		</script>
	</body>
</html>